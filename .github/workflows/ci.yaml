name: kubernetes-demo

on:
  push:
    branches: [ main ]
  pull_request:

# Needed to read code; Pages perms are set on the deploy job
permissions:
  contents: read

jobs:
  build-and-test:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      # 1) Create a Kubernetes cluster in Docker (KIND)
      - name: Create KIND cluster
        uses: helm/kind-action@v1
        with:
          cluster_name: portfolio-demo
          node_image: kindest/node:v1.30.0

      # 2) Install NGINX Ingress in KIND for realism
      - name: Install ingress-nginx
        run: |
          kubectl apply -f https://raw.githubusercontent.com/kubernetes/ingress-nginx/main/deploy/static/provider/kind/deploy.yaml
          kubectl -n ingress-nginx rollout status deployment/ingress-nginx-controller --timeout=120s

      # 3) Install Argo CD (fix: controller is a StatefulSet, not a Deployment)
      - name: Install Argo CD
        run: |
          kubectl create namespace argocd || true
          kubectl apply -n argocd -f https://raw.githubusercontent.com/argoproj/argo-cd/stable/manifests/install.yaml
          # Wait for core components
          kubectl -n argocd rollout status deploy/argocd-repo-server --timeout=180s
          kubectl -n argocd rollout status deploy/argocd-server --timeout=180s
          kubectl -n argocd rollout status sts/argocd-application-controller --timeout=180s

      # 4) Apply Argo CD root app and capture state
      - name: Apply Argo CD root app and capture state
        run: |
          mkdir -p site
          kubectl apply -f apps/argo/root-app.yaml
          # give Argo some time to reconcile
          sleep 20
          kubectl -n argocd get applications -o wide | tee site/argo-apps.txt

      # 5) Deploy demo workload (keep if Argo root DOES NOT manage demo-web)
      - name: Apply demo app
        run: |
          kubectl apply -f apps/workloads/demo-web/
          kubectl rollout status deploy/demo-web --timeout=120s

      # 6) Smoke-test the Service via port-forward and collect evidence
      - name: Smoke test & collect evidence
        run: |
          mkdir -p site
          # capture cluster state
          {
            echo "=== Cluster Info ==="
            kubectl cluster-info
            echo
            echo "=== Nodes ==="
            kubectl get nodes -o wide
            echo
            echo "=== Pods (all namespaces) ==="
            kubectl get pods -A -o wide
            echo
            echo "=== Services (namespace default) ==="
            kubectl get svc
          } | tee site/kubectl-summary.txt

          # port-forward to Service and fetch homepage
          kubectl port-forward svc/demo-web 8080:80 &
          PF_PID=$!
          sleep 5
          curl -sS http://localhost:8080 > site/index.html || true
          kill $PF_PID || true

          # simple landing page linking artifacts
          cat > site/readme.html <<'HTML'
          <!doctype html><meta charset="utf-8">
          <h1>Kubernetes Demo (KIND in GitHub Actions)</h1>
          <p>This site is generated by the CI job. Below are artifacts proving a running cluster and app.</p>
          <ul>
            <li><a href="kubectl-summary.txt">kubectl-summary.txt</a> (cluster state)</li>
            <li><a href="index.html">index.html</a> (nginx homepage captured via port-forward)</li>
            <li><a href="argo-apps.txt">argo-apps.txt</a> (Argo CD Applications snapshot)</li>
          </ul>
          HTML

      # 7) Upload site as an artifact for the deploy job
      - name: Upload Pages artifact
        uses: actions/upload-pages-artifact@v3
        with:
          path: ./site

  deploy:
    needs: build-and-test
    permissions:
      pages: write      # to deploy to Pages
      id-token: write   # to authenticate to Pages
    environment:
      name: github-pages
      url: ${{ steps.deployment.outputs.page_url }}
    runs-on: ubuntu-latest
    steps:
      - name: Deploy to GitHub Pages
        id: deployment
        uses: actions/deploy-pages@v4
